import 'package:flutter/material.dart';
import 'package:juniper_journal/src/shared/styling/theme.dart';
import 'package:intl/intl.dart';
import 'package:juniper_journal/src/features/learning_module/learning_module.dart';
import '../../../backend/db/repositories/learning_module_repo.dart';

/*
Purpose:
  Identifies the core scientific concepts, inquiry methods, and cross-disciplinary frameworks that underpin the lesson.
  Ensures alignment with NGSS and supports deeper, more coherent science learning by clarifying what students engage with
  beyond just the tasks they complete.

Key Functions:
  - Dropdowns for easy multi-select options
  - Supports multi-dimensional NGSS alignment
  - Organized into three NGSS-aligned components:

Disciplinary Core Ideas (DCI):
  Identify the central science concepts and knowledge areas explored in the lesson.
  Grouped by domain

Science and Engineering Practices (SEP):
  Describe how students engage in scientific inquiry and investigation.

Crosscutting Concepts (CCC):
  Identify the conceptual lenses that connect ideas across science disciplines.

Creator Actions / Behaviors:
  - Select one or more DCIs based on lesson content.
  - Choose SEPs to define inquiry and investigation approaches.
  - Identify relevant CCCs to highlight conceptual connections.
  - Use dropdown menus to streamline selection and ensure NGSS alignment.

User Actions / Behaviors:
  - View selected DCIs to understand core science concepts.
  - See tagged SEPs to understand inquiry expectations.
  - Interpret CCCs as guiding frameworks linking lessons to broader scientific thinking.
*/

class ThreeDLearning extends StatefulWidget {
  final Map<String, dynamic> module;

  const ThreeDLearning({super.key, required this.module});

  @override
  State<ThreeDLearning> createState() => _ThreeDLearningState();
}

class _ThreeDLearningState extends State<ThreeDLearning> {
  Map<String, dynamic>? _freshModuleData;

  // ---------------- Options ----------------
  // DCI options mapped by subject domain
  final Map<String, List<String>> _dciOptionsByDomain = {
    'Environmental Sustainability': [
      'Ecosystems & Biodiversity',
      'Climate & Weather Patterns',
      'Human Impact on Natural Systems',
      'Natural Resources & Conservation',
      'Pollution and Waste Management',
    ],
    'Engineering & Design': [
      'Defining and Delimiting Engineering Problems',
      'Designing Solutions and Prototyping',
      'Materials and Their Properties',
      'Iteration and Improvement Processes',
      'Sustainable Innovation and Practices',

    ],
    'Energy & Systems': [
      'Energy Sources and Forms',
      'Energy Transfer and Transformation',
      'Renewable and Nonrenewable Resources',
      'Efficiency and Conservation of Energy',
      'Energy Flow in Natural and Engineered Systems'

    ],
    'Community & The Built Environment': [
      'Sustainable Communities and Urban Planning',
      'Green Building and Infrastructure',
      'Transportation and Mobility Systems',
      'Public Space Design and Equity',
      'Interaction Between Human and Natural Environments'

    ],
  };

  final List<String> _sepOptions = const [
    'Asking Questions and Defining Problems',
    'Developing and Using Models',
    'Planning and Carrying Out Investigations',
    'Analyzing and Interpreting Data',
    'Using Mathematics and Computational Thinking',
    'Constructing Explanations and Designing Solutions',
    'Engaging in Argument from Evidence',
    'Obtaining, Evaluating, and Communicating Information',
  ];

  final List<String> _cccOptions = const [
    'Patterns',
    'Cause and Effect',
    'Algorithms and Equations',
    'Scale, Proportion, and Quantity',
    'Systems and System Models',
    'Energy and Matter',
    'Structure and Function',
    'Stability and Change',
  ];

  // ------------- Dynamic selections (multiple) -------------
  // Start with one empty pill for each section
  final List<String?> _dci = [];
  final List<String?> _sep = [null];
  final List<String?> _ccc = [null];

  // Track number of auto-generated DCIs (these cannot be removed)
  int _autoGeneratedDciCount = 0;

  @override
  void initState() {
    super.initState();
    _loadFreshModuleData();
  }

  void _loadFreshModuleData() async {
    if (widget.module['id'] != null) {
      final repo = LearningModuleRepo();
      final freshData = await repo.getModule(widget.module['id'].toString());
      if (freshData != null) {
        setState(() {
          _freshModuleData = freshData;
          _loadSubjectDomains(freshData);
          _loadSEPAndCCC(freshData);
        });
      }
    }
  }

  void _loadSubjectDomains(Map<String, dynamic> moduleData) {
    try {
      List<dynamic> subjectDomains = [];

      // Handle subject_domain from DB (same logic as learning_objective.dart)
      final domainData = moduleData['subject_domain'];
      if (domainData is List) {
        subjectDomains = domainData;
      } else if (domainData is String && domainData.isNotEmpty) {
        if (domainData.startsWith('[') && domainData.endsWith(']')) {
          try {
            final cleanString = domainData.substring(1, domainData.length - 1);
            subjectDomains = cleanString
                .split(',')
                .map((s) => s.trim().replaceAll('"', '').replaceAll("'", ''))
                .where((s) => s.isNotEmpty)
                .toList();
          } catch (e) {
            subjectDomains = [domainData];
          }
        } else {
          subjectDomains = [domainData];
        }
      }

      // Auto-populate DCI based on subject domains
      _dci.clear();
      _autoGeneratedDciCount = 0;
      for (String domain in subjectDomains) {
        final dciOptions = _dciOptionsByDomain[domain];
        if (dciOptions != null && dciOptions.isNotEmpty) {
          // Add first DCI option for this domain with domain prefix
          _dci.add('$domain: ${dciOptions[0]}');
          _autoGeneratedDciCount++;
        }
      }

      // If no domains found, add one empty slot
      if (_dci.isEmpty) {
        _dci.add(null);
      }
    } catch (e) {
      debugPrint('Error loading subject domains: $e');
      _dci.clear();
      _dci.add(null);
    }
  }

  /// Loads saved SEP and CCC data from the database
  void _loadSEPAndCCC(Map<String, dynamic> moduleData) {
    try {
      // Load SEP data
      final sepData = moduleData['sep'];
      if (sepData != null) {
        List<String> sepList = [];

        if (sepData is List) {
          sepList = List<String>.from(sepData.where((item) => item != null));
        } else if (sepData is String && sepData.isNotEmpty) {
          if (sepData.startsWith('[') && sepData.endsWith(']')) {
            try {
              final cleanString = sepData.substring(1, sepData.length - 1);
              sepList = cleanString
                  .split(',')
                  .map((s) => s.trim().replaceAll('"', '').replaceAll("'", ''))
                  .where((s) => s.isNotEmpty)
                  .toList();
            } catch (e) {
              sepList = [sepData];
            }
          } else {
            sepList = [sepData];
          }
        }

        if (sepList.isNotEmpty) {
          _sep.clear();
          _sep.addAll(sepList);
        }
      }

      // Load CCC data
      final cccData = moduleData['ccc'];
      if (cccData != null) {
        List<String> cccList = [];

        if (cccData is List) {
          cccList = List<String>.from(cccData.where((item) => item != null));
        } else if (cccData is String && cccData.isNotEmpty) {
          if (cccData.startsWith('[') && cccData.endsWith(']')) {
            try {
              final cleanString = cccData.substring(1, cccData.length - 1);
              cccList = cleanString
                  .split(',')
                  .map((s) => s.trim().replaceAll('"', '').replaceAll("'", ''))
                  .where((s) => s.isNotEmpty)
                  .toList();
            } catch (e) {
              cccList = [cccData];
            }
          } else {
            cccList = [cccData];
          }
        }

        if (cccList.isNotEmpty) {
          _ccc.clear();
          _ccc.addAll(cccList);
        }
      }
    } catch (e) {
      debugPrint('Error loading SEP and CCC: $e');
    }
  }

  // Get selected subject domains from module data
  List<String> _getSelectedSubjectDomains() {
    if (_freshModuleData == null) return [];

    List<String> subjectDomains = [];
    final domainData = _freshModuleData!['subject_domain'];

    if (domainData is List) {
      subjectDomains = List<String>.from(domainData);
    } else if (domainData is String && domainData.isNotEmpty) {
      if (domainData.startsWith('[') && domainData.endsWith(']')) {
        try {
          final cleanString = domainData.substring(1, domainData.length - 1);
          subjectDomains = cleanString
              .split(',')
              .map((s) => s.trim().replaceAll('"', '').replaceAll("'", ''))
              .where((s) => s.isNotEmpty)
              .toList();
        } catch (e) {
          subjectDomains = [domainData];
        }
      } else {
        subjectDomains = [domainData];
      }
    }

    return subjectDomains;
  }

  // Generate DCI options filtered by selected subject domains
  List<String> _getFilteredDciOptions() {
    List<String> filteredOptions = [];
    final selectedDomains = _getSelectedSubjectDomains();

    for (String domain in selectedDomains) {
      final dciOptions = _dciOptionsByDomain[domain];
      if (dciOptions != null) {
        for (String dci in dciOptions) {
          filteredOptions.add('$domain: $dci');
        }
      }
    }

    return filteredOptions;
  }

  // ---------------- Utilities ----------------

  String _formatDate(String? createdAt) {
    if (createdAt == null) return 'Date not available';

    try {
      final dateTime = DateTime.parse(createdAt).toLocal();
      final formatter = DateFormat('EEEE, MMMM d');
      return formatter.format(dateTime);
    } catch (e) {
      return 'Date error';
    }
  }

  Future<void> _pickOption({
    required String title,
    required List<String> options,
    required String? current,
    required ValueChanged<String> onPicked,
  }) async {
    final picked = await showModalBottomSheet<String>(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => SafeArea(
        top: false,
        child: DraggableScrollableSheet(
          expand: false,
          initialChildSize: 0.6,
          minChildSize: 0.4,
          maxChildSize: 0.9,
          builder: (context, scrollController) {
            return Column(
              children: [
                const SizedBox(height: 12),
                Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.black12,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
                const SizedBox(height: 12),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 20.0),
                  child: Align(
                    alignment: Alignment.centerLeft,
                    child: Text(
                      title,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                        color: AppColors.textPrimary,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                Expanded(
                  child: ListView.builder(
                    controller: scrollController,
                    padding: const EdgeInsets.only(bottom: 12),
                    itemCount: options.length,
                    itemBuilder: (_, i) {
                      final o = options[i];
                      final selected = o == current;
                      return ListTile(
                        title: Text(
                          o,
                          style: TextStyle(
                            color: AppColors.textPrimary.withValues(alpha: selected ? 1.0 : 0.95),
                          ),
                        ),
                        trailing: selected
                            ? const Icon(Icons.check, color: AppColors.border)
                            : null,
                        onTap: () => Navigator.of(ctx).pop(o),
                      );
                    },
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );

    if (picked != null && picked != current) onPicked(picked);
  }

  // Open a picker and set the selection at list[index]
  Future<void> _editItem({
    required List<String?> list,
    required int index,
    required String title,
    required List<String> options,
  }) async {
    await _pickOption(
      title: title,
      options: options,
      current: list[index],
      onPicked: (v) => setState(() => list[index] = v),
    );
  }

  // Add a new pill for the section (and immediately open picker)
  Future<void> _addItem({
    required List<String?> list,
    required String title,
    required List<String> options,
  }) async {
    setState(() => list.add(null));
    final newIndex = list.length - 1;
    await _editItem(
      list: list,
      index: newIndex,
      title: title,
      options: options,
    );
  }

  // Remove a pill; if list becomes empty, add a blank one back
  void _removeItem(List<String?> list, int index) {
    setState(() {
      list.removeAt(index);
      if (list.isEmpty) {
        list.add(null);
      }
    });
  }

  // ---------------- UI ----------------
  @override
  Widget build(BuildContext context) {
    final moduleName = widget.module['module_name'] ?? 'Module Name';
    final formattedDate = _formatDate(widget.module['created_at']);

    return Scaffold(
      appBar: AppBar(
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: AppColors.border),
          onPressed: () => Navigator.pop(context),
        ),
        title: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              moduleName,
              style: const TextStyle(
                color: AppColors.textPrimary,
                fontSize: 20,
                fontWeight: FontWeight.w600,
              ),
            ),
            Text(
              formattedDate,
              style: const TextStyle(
                color: AppColors.textSecondary,
                fontSize: 14,
              ),
            ),
          ],
        ),
        centerTitle: false,
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20.0),
          child: ListView(
            children: [
              // LEARNING pill with navigation
              Align(
                alignment: Alignment.centerLeft,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.green[100],
                    borderRadius: BorderRadius.circular(20),
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<String>(
                      value: 'LEARNING',
                      icon: const Icon(
                        Icons.keyboard_arrow_down,
                        color: Colors.green,
                        size: 16,
                      ),
                      style: const TextStyle(
                        color: Colors.green,
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                      dropdownColor: Colors.green[50],
                      items: const [
                        DropdownMenuItem(
                          value: 'TITLE',
                          child: Text(
                            'TITLE',
                            style: TextStyle(
                              color: Colors.green,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        DropdownMenuItem(
                          value: 'ANCHORING PHENOMENON',
                          child: Text(
                            'ANCHORING PHENOMENON',
                            style: TextStyle(
                              color: Colors.green,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        DropdownMenuItem(
                          value: 'OBJECTIVE',
                          child: Text(
                            'OBJECTIVE',
                            style: TextStyle(
                              color: Colors.green,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        DropdownMenuItem(
                          value: 'LEARNING',
                          child: Text(
                            'LEARNING',
                            style: TextStyle(
                              color: Colors.green,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ],
                      onChanged: (value) {
                        if (value == 'TITLE') {
                          Navigator.of(context).popUntil((route) => route.isFirst);
                          Navigator.of(context).push(
                            MaterialPageRoute(
                              builder: (context) => CreateTemplateScreen(
                                existingModule: widget.module,
                              ),
                            ),
                          );
                        } else if (value == 'ANCHORING PHENOMENON') {
                          Navigator.of(context).popUntil((route) => route.isFirst);
                          Navigator.of(context).push(
                            MaterialPageRoute(
                              builder: (context) => AnchoringPhenomenon(
                                existingModule: widget.module,
                              ),
                            ),
                          );
                        } else if (value == 'OBJECTIVE') {
                          Navigator.of(context).pop();
                        }
                        // If LEARNING is selected, stay on current page
                      },
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // -------- DCI --------
              const _SectionHeader('Disciplinary Core Ideas (DCI)'),
              ..._dci.asMap().entries.map(
                (e) => Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: e.key < _autoGeneratedDciCount
                      ? _NonEditablePill(label: e.value ?? 'Select DCI')
                      : _RoundedChoicePill(
                          label: e.value ?? 'Select DCI',
                          onTap: () => _editItem(
                            list: _dci,
                            index: e.key,
                            title: 'Select DCI',
                            options: _getFilteredDciOptions(),
                          ),
                          onRemove: () => _removeItem(_dci, e.key),
                        ),
                ),
              ),
              _AddCircleButton(
                onTap: () => _addItem(
                  list: _dci,
                  title: 'Select DCI',
                  options: _getFilteredDciOptions(),
                ),
              ),

              // -------- SEP --------
              const SizedBox(height: 22),
              const _SectionHeader('Science and Engineering Practices (SEP)'),
              ..._sep.asMap().entries.map(
                (e) => Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: _RoundedChoicePill(
                    label: e.value ?? 'Select SEP',
                    onTap: () => _editItem(
                      list: _sep,
                      index: e.key,
                      title: 'Select SEP',
                      options: _sepOptions,
                    ),
                    onRemove: () => _removeItem(_sep, e.key),
                  ),
                ),
              ),
              _AddCircleButton(
                onTap: () => _addItem(
                  list: _sep,
                  title: 'Select SEP',
                  options: _sepOptions,
                ),
              ),

              // -------- CCC --------
              const SizedBox(height: 22),
              const _SectionHeader('Cross Cutting Concepts (CCC)'),
              ..._ccc.asMap().entries.map(
                (e) => Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: _RoundedChoicePill(
                    label: e.value ?? 'Select CCC',
                    onTap: () => _editItem(
                      list: _ccc,
                      index: e.key,
                      title: 'Select CCC',
                      options: _cccOptions,
                    ),
                    onRemove: () => _removeItem(_ccc, e.key),
                  ),
                ),
              ),
              _AddCircleButton(
                onTap: () => _addItem(
                  list: _ccc,
                  title: 'Select CCC',
                  options: _cccOptions,
                ),
              ),

              // Complete button
              const SizedBox(height: 24),
              SizedBox(
                height: 56,
                child: ElevatedButton(
                  onPressed: () async {
                    final messenger = ScaffoldMessenger.of(context);
                    final repo = LearningModuleRepo();
                    final moduleId = widget.module['id'].toString();

                    try {
                      // Prepare data for database updates
                      final dciData = _dci
                          .where((item) => item != null && item.isNotEmpty)
                          .map((item) => item!)
                          .toList();

                      final sepData = _sep
                          .where((item) => item != null && item.isNotEmpty)
                          .map((item) => item!)
                          .toList();

                      final cccData = _ccc
                          .where((item) => item != null && item.isNotEmpty)
                          .map((item) => item!)
                          .toList();

                      // Validation: Check that SEP and CCC have at least one selection
                      if (sepData.isEmpty) {
                        messenger.showSnackBar(
                          const SnackBar(
                            content: Text('Please select at least one Science and Engineering Practice (SEP)'),
                            backgroundColor: AppColors.error,
                          ),
                        );
                        return;
                      }

                      if (cccData.isEmpty) {
                        messenger.showSnackBar(
                          const SnackBar(
                            content: Text('Please select at least one Cross Cutting Concept (CCC)'),
                            backgroundColor: AppColors.error,
                          ),
                        );
                        return;
                      }

                      final navigator = Navigator.of(context);

                      // Update database with all three fields
                      final dciSuccess = await repo.updateDCI(
                        id: moduleId,
                        dci: dciData,
                      );

                      final sepSuccess = await repo.updateSEP(
                        id: moduleId,
                        sep: sepData,
                      );

                      final cccSuccess = await repo.updateCCC(
                        id: moduleId,
                        ccc: cccData,
                      );

                      if (dciSuccess && sepSuccess && cccSuccess) {
                        navigator.push(
                          MaterialPageRoute(
                            builder: (context) => ConceptExplorationScreen(
                              module: widget.module,
                            ),
                          ),
                        );
                      } else {
                        messenger.showSnackBar(
                          const SnackBar(
                            content: Text('Failed to save some data. Please try again.'),
                            backgroundColor: AppColors.error,
                          ),
                        );
                      }
                    } catch (e) {
                      messenger.showSnackBar(
                        const SnackBar(
                          content: Text('Error saving module data'),
                          backgroundColor: AppColors.error,
                        ),
                      );
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primary,
                    foregroundColor: AppColors.buttonText,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                  ),
                  child: const Text(
                    'Complete',
                    style: TextStyle(
                      fontWeight: FontWeight.w600,
                      fontSize: 16,
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 28),
            ],
          ),
        ),
      ),
    );
  }
}

/* ---------- UI widgets ---------- */

class _SectionHeader extends StatelessWidget {
  final String text;
  const _SectionHeader(this.text);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 10.0, top: 6.0),
      child: Text(
        text,
        style: const TextStyle(
          color: AppColors.textPrimary,
          fontSize: 16.5,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}

class _NonEditablePill extends StatelessWidget {
  final String label;

  const _NonEditablePill({
    required this.label,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 12),
      decoration: BoxDecoration(
        color: AppColors.lightBlue,
        borderRadius: BorderRadius.circular(28),
      ),
      child: Row(
        children: [
          // Empty space to match layout
          const SizedBox(width: 30),

          // label centered
          Expanded(
            child: Text(
              label,
              textAlign: TextAlign.center,
              style: const TextStyle(
                color: AppColors.blue,
                fontSize: 15,
                fontWeight: FontWeight.w700,
              ),
            ),
          ),

          // No chevron for non-editable
          const SizedBox(width: 30),
        ],
      ),
    );
  }
}

class _RoundedChoicePill extends StatelessWidget {
  final String label;
  final VoidCallback onTap;
  final VoidCallback? onRemove;

  const _RoundedChoicePill({
    required this.label,
    required this.onTap,
    this.onRemove,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: AppColors.lightBlue,
      borderRadius: BorderRadius.circular(28),
      child: InkWell(
        borderRadius: BorderRadius.circular(28),
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 12),
          child: Row(
            children: [
              // remove button (left)
              if (onRemove != null)
                InkResponse(
                  onTap: onRemove,
                  customBorder: const CircleBorder(),
                  child: const Padding(
                    padding: EdgeInsets.all(6.0),
                    child: Icon(Icons.close, size: 18, color: Colors.black38),
                  ),
                )
              else
                const SizedBox(width: 30),

              // label centered
              Expanded(
                child: Text(
                  label,
                  textAlign: TextAlign.center,
                  style: const TextStyle(
                    color: AppColors.blue,
                    fontSize: 15,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),

              // chevron (right)
              const Padding(
                padding: EdgeInsets.only(left: 6.0),
                child: Icon(Icons.expand_more, color: AppColors.blue),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _AddCircleButton extends StatelessWidget {
  final VoidCallback onTap;
  const _AddCircleButton({required this.onTap});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 14.0),
      child: Center(
        child: InkWell(
          customBorder: const CircleBorder(),
          onTap: onTap,
          child: Container(
            width: 34,
            height: 34,
            decoration: BoxDecoration(
              color: Colors.black12.withValues(alpha: 0.08),
              shape: BoxShape.circle,
            ),
            child: const Icon(Icons.add, size: 18, color: Colors.black26),
          ),
        ),
      ),
    );
  }
}
